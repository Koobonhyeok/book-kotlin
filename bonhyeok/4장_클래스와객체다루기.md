## 클래스 정의하기
***

### 클래스 내부 구조
 자바와 마찬가지로, 코틀린 클래스도 class 키워드 다음에 클래스 이름이 오고 그다음에 클래스 본문에 오는
 형태로 정의된다.
 ``` kotlin
    class Person{
        var firstName: String = ""
        var familyName: String = ""
        var age: Int = 0
        
        fun fullName() = "$firstName $familyName"
        
        fun showMe(){
            println("${fullName()}: $age")
        }
    }
 ```
 클래스 내부에서는 this 식으로 수신 객체를 참조할 수 있다. 대부분의 경우 this를 디폴트로 가정하기 때문에
수신 객체의 멤버 안에서 수신 객체의 멤버를 참조할 때는 this를 생략해도 된다.
```kotlin
    class Person{
        var firstName: String = ""
        var familyName: String = ""
        var age: Int = 0
    
        fun fullName() = "${this.firstName} ${this.familyName}"
        fun showMe(){
            println("${this.fullName()} : ${this.age}")
        }
    }
```
 하지만 때로는 this가 꼭 필요한 경우도 있다. 예를 들어 어떤 클래스의 프로퍼티와 메서드 파라미터
이름이 같은 경우, 이 둘을 구분하기 위해 프로퍼티 이름 앞에 this를 써야 한다.
```text
 자바vs코틀린 :  자바 필드와 달리, 코틀린에서는 클라이언트 코드를 바꾸지 않아도 원하는 대로 프로퍼티의 구현을 
            바꿀 수 있기 때문에 코틀린 프로퍼티는 캡슐화에 위배되지 않는다.
```
 생성자 호출을 사용하면 프로그램이 새 인스턴스에 대한 힙 메모리를 할당한 다음, 인스턴스의 상태를 초기화해주는
생성자 코드를 호출해준다.

 기본적으로 코틀린 클래스는 공개 가시성이다. 이 말은 코드의 어느 부분에서나 클래스를 사용할 수 있다는 뜻이다.
최상위 함수와 마찬가지로 최상위 클래스를 internal이나 private으로 설정할 수 있다 .
***

### 생성자
 생성자는 클래스 인스턴스를 초기화해주고 인스턴스 생성 시 호출되는 특별한 함수다.
```kotlin
class Person(firstName: String, familyName: String){
    val fullName = "$firstName $familyName"
    
    fun main(){
        val person = Person("John", "Doe")
        println( person.fullName )
    }
}
```
 class 키워드 이름 뒤에 덧붙인 파라미터 목록을 살펴보자. 이 파라미터는 프로그램이 클래스의 인스턴스를
생성할 때 클래스에 전달된다. 이 파라미터를 사용해 프로퍼티를 초기화하고 다른 일을 수행할 수 있다.

```text
 자바vs코틀린  : 코틀린에서는 생성자를 호출할 때 자바의 new와 같은 틀별한 키워드를 사용하지 않는다.
```
클래스 헤더의 파라미터 목록을 주생성자 선언이라고 부른다. 주생성자는 함수와 달리 본문이 하나가 아니다.
대신 주생성자는 클래스 정의 내에서 프로퍼티 초기화와 초기화 블록이 등장하는 순서대로 구성된다.
초기화 블록이란 init이라는 키워드가 앞에 붙은 블록이다.

지금까지는 항상 프로퍼티 값을 프로퍼티 정의 시 초기화했다. 하지만 하나의 식으로 표현하기 어려운 복잡한 
최화 로직을 실행해야 프로퍼티를 초기화할 수 있는 경우도 있다. 이런 이유로 코틀린은 init 블록 안에서
프로퍼티를 초기화하는 것도 허용한다.
```kotlin
class Person(fullName: String){
    val firstName: String
    val familyName: String
    init{
        val names = fullName.split(" ")
        
        if( names.size != 2){
            throw IllegalArgumentException("IllegalArgumentException")
        }
        firstName = names[0]
        familyName = names[1]
    }
}

fun main(){
    val person = Person("John Doe")
    println(person.firstNames)
}
```
주생성자 파라미터를 프로퍼티 초기화나 init 블록 밖에서 사용할 수 없다. 예를 들어 멤버 함수 내부에서는
firstName을 사용할 수 없기 때문에 다음 코드는 잘못된 코드다.
```kotlin
class Person(firstName: String, familyName: String){
    val fullName = "$firstName $familyName"
    fun printFristName(){
        println(firstName) // error
    }
}
```
이에 대한 해법은 생성자 파마리터의 값을 저장할 멤버 프로퍼티를 정의하는 것이다.
```kotlin
class Person(firstName: String, familyName: String){
    val firstName = firstName
    val fullName = "$firstName $familyName"
 
    fun printFirstName(){
        println(firstName)
    }
}

//---------------------------------------------
class Person(val firstName: String, familyName: String){
    val fullName = "$firstName $familyName"
   
    fun printFirstName(){
        println(firstName)
    }
}
fun main(){
    val person = Person("John", "Doe")
    println(person.firstName)
}
```
기본적으로 생성자 파라미터 앞에 val이나 var 키워드를 덧붙이면, 자동으로 해당 생성자 파라미터로 
초기화되는 프로퍼티를 정의한다.

여러 생성자를 사용해 클래스 인스턴스를 서로 다른 방법으로 초기화하고 싶을 떄도 있다. 이런 경우도
대부분은 디폴트 파라미터를 사용하는 주생성자로 해결할 수 있지만, 경우에 따라 주생성자만으로는 충분하지
않을 수도 있다. 코틀린에서는 이런 문제를 부생성자를 사용해 해결할 수 있다. 부생성자 문법은 함수 이름
대신에 constructor 키워드를 사용한다는 점을 제외하면 함수 정의 문법과 동일하다.
```kotlin
class Person{
    val firstName: String
    val familyName: String
    
    constructor(firstName: String, familyName: String){
        this.firstName = firstName
        this.familyName = familyName
    }
    
    constructor(fullName: String){
        val names = fullName.split(" ")
     
        if( names.size != 2 ){
         throw IllegalArgumentException("IllegalArgumentException")
        }
        firstName = names[0]
        familyName = names[1]
    }
}
```
부생성자는 반환 타입을 지정할 수는 없지만, 기본적으로 부생성자는 Unit 타입 값을 반환하는 함수와
마찬가지 형태다. 특히 (init 블록과 달리) 부생성자 안에서는 return을 사용할 수 있다.

