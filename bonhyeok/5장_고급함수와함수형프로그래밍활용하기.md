## 코틀린을 활용한 함수형 프로그래밍
***

### 고차 함수
**ChatGPT**  
코틀린에서 코차함수는 함수 자체를 인수로 받거나, 함수를 반환하는 함수이다. 고차함수를 사용하는 주요 이유는
코드의 재사용성을 높이고, 간경하고 명확한 코드를 작성할 수 있기 때문이다.

```kotlin
fun main(){
    println( sum(intArrayOf(1, 2, 3))  ) // 6
    println( max(intArrayOf(1, 2, 3))  ) // 3
}

fun aggregate(numbers: IntArray, op: (Int, Int) -> Int): Int {
    var result = numbers.firstOrNull()?: throw IllegalArgumentException("Empty array")

    for( i in 1..numbers.lastIndex ){
        result = op(result, numbers[i])
    }
    return result;
}

fun sum(numbers: IntArray) = aggregate(numbers, {result, op -> result + op})

fun max(numbers: IntArray) = aggregate(numbers, {result, op -> if(op > result) op else result})
```
***

### 함수 타입

함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다. 문법적으로 이런 타입은 함수 시그니처와 비슷하며,
아래와 같이 두 가지 부분으로 구성된다.
1. 괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.
2. 반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.

반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시해야 한다. 따라서 이런 경우 Unit을 반환
타입으로 사용한다.

```kotlin
fun interface StringConsumer{
    fun accept(s:String)
}

fun main(){
    val consume = StringConsumer{ s-> println(s) }

    consume.accept("Hello")
}
```

함수 타입의 값을 함수의 파라미터에만 사용할 수 있는 것도 아니다. 실제로는 이런 함수 타입을 다른 타입이 쓰일
수 있는 모든 장소에 사용할 수 있다.
```kotlin
fun main(){
    val lessThan: (Int, Int) -> Boolean = {a, b -> a < b}
    println(lessThan(1, 2))
}
```
변수 타입을 생략하면 정보가 충분하지 못해 컴파일러가 람다 파라미터의 타입을 추론할 수 없다
```kotlin
val lessThan = { a, b -> a < b } // error: connot infer a type this parameter
val lessThan1 = { a: Int, b: Int -> a < b} // OK
```
다른 타입과 마찬가지로 함수 타입도 널이 될 수 이쓴ㄴ 타입으로 지정할 수 있다.
이럴 때는 함수 타입 전체에 괄호로 둘러싼 다음에 물을표를 붙인다.
```kotlin
fun measureTime(action: (() -> Unit)?): Long{
    val start = System.nanoTime();
    
    action?.invoke()
    
    return System.nanoTime() - start
}

fun main(){
    println(measureTime(null))
}
// invoke눈 action이 null이 아닐 경우에만 invoke()를 호출하여 action 함수를 실행한다.
```
***

### 람다와 익명 함수
 함수형 타입의 구체적인 값을 어떻게 만들 수 있을까? 한 가지 방법은 함수를 묘사하되 이름을 지정하지는 않는
 람다식을 사용하는 것이다. 예를 들어 앞에서 본 aggregate() 선언을 활용해 합계와 최댓값을 계산하는
 함수를 만들어 보자
 ```kotlin
//fun sum1(numbers: IntArray) =
//    aggregate(numbers, {result, op -> result+op})
//
//fun max1(numbers: IntArray) =
//    aggregate(numbers, {result, op -> if( op > result) op else result })
//
//fun main() {
//    println(sum1(intArrayOf(1, 2, 3)))  // 6
//    println(max1(intArrayOf(1, 2, 3,))) // 3
//}
```
{result, op -> result + op }라는 식을 람다식이라고 부른다. 람다식 정의는 함수 정의와 비슷하게 
다음과 같은 요소로 이뤄진다.
- 파라미터 목록: result, op
- 람다식의 몸동이 되는 식이나 문의 목록: result + op

함수 정의와 달리 반환 타입을 지정할 필요가 없으며, 람다의 본문으로부터 반환 타입이 자동으로 추론된다.
그리고 람다 본문에서 맨 마지막에 있는 식이 람다의 결괏값이 된다.

코틀린은 인자가 하나밖에 없는 람다를 특별히 단순화해 사용할 수 있는 문법을 제공한다.
람다 인자가 하나인 경우에는 파라미터 목록과 화살표 기호를 생략하고, 유일한 파라미터는 미리 정해진
it 이라는 이름을 사용해 가리킬 수 있다.
```kotlin
fun main() {
    println(check("Hello") {c -> c.isLetter()} )
    println(check("Hello") { it.isLowerCase()} )
}

fun check(s: String, condition: (Char) -> Boolean):Boolean {
    for(c in s){
        if(!condition(c)) return false
    }

    return true
}
```

코틀린 1.1부터는 람다의 파라미터 목록에서 사용하지 않는 람다 파라미터를 밑줄 기호(_)로 지정할 수 있다.
```kotlin
fun main() {
    println(check("Hello") { _, c -> c.isLetter()} )
    println(check("Hello") { i, c -> i == 0 || c.isLowerCase()} )
}

fun check(s: String, condition: (Int, Char) -> Boolean):Boolean {
    for(i in s.indices){
       
        if(!condition(i, s[i])) return false
    }

    return true
}
```
함수값을 만드는 다른 방법은 익명 함수를 사용하는 것이다.
```kotlin
//fun sum(numbers: IntArray) = aggregate(numbers, fun(result, op) = result + op)
```
익명 함수의 문법은 일반 함수의 문법과 거의 동일하다. 몇 가지 차이점을 정리하면 다음과 같다.
- 익명 함수에는 이름을 지정하지 않는다. 따라서 fun 키워드 다음에 바로 파라미터 목록이 온다.
- 람다와 마찬가지로 문맥에서 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
- 함수 정의와 달리, 익명 함수는 식이기 때문에 인자로 함수에 넘기거나 변수에 대입하는 등 일반 값처럼
쓸 수 있다.

람다와 달리 익명 함수에는 반환 타입을 적을 수 있다. 반환 타입 관련해서는 함수 정의 시와 익명 함수
정의 시에 똑같은 규칙을 적용한다. 즉, 함수 본문이 식인 경우에는 반환 타입을 생략할 수 있고, 함수 본문
이 블록인 경우 에는 명시적으로 반환 타입을 지정해야 한다.
```kotlin
//fun sum(numbers: IntArray) = aggregate(numbers, fun(result, op): Int {return result+op})
```
람다와 달리 익명 함수를 인자 목록의 밖으로 내보낼 수는 없다.
***

### 호출 가능 참조