## 함수 
 *  자바 메서드처럼 코틀린 함수도 어떤 입력을 받아서 자신을 호출한 코드 쪽에 출력값을 반환할 수 있는 재사용 가능한 코드 블록이다.

---
#### 코틀린 함수의 구조
자바와 마찬가지로 함수의 결과값을 return 문으로 지정한다. return 문은 함수 실행을 끝내고 호출한 쪽에 제어를
돌려준다. return 문 다음에 위치한 코드는 실질적으로 죽어있는 코드이며, 결코 실행되지 않는다.  

자바처럼 코틀린에도 블록 문이 있다. 블록 문은 기본적으로 {}로 감싼 문의 그룹을 말한다. 
문은 새줄 문자로 분리하거나 세미콜론으로 분리하며, 순서대로 실행된다.

```kotlin
    fun increment(n: Int): Int{
        return n++      // Error : can not change immutable variable
    }
```
자바 메서드 파라미터는 디폴트가 가변이므로 함수 내부에서 변경하지 못하게 하려면 final을 지정해 불변 값으로
바꿔야 하는데, 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하하면 위의 코드 같이 오류가 발생한다.
그리고 파라미터 앞에 **val이나 var**를 표시할 수 없다는 점을 유의하라. 이렇게 강제하는 이유는 
파라미터에 대입하는 중에 실수할 가능성이 높을 뿐 아니라 파라미터를 불변 값으로 강제하는 편이 더 깔끔하고
이해하기 편한 코드를 만들어 내기 때문이다.

```kotlin
    fun increment(a: IntArray): Int{
        return ++a[0]
    }

    fun main(){
        val a = intArrayOf(1, 2, 3)
        println( increment(a) )             // 2
        println( a.contentToString() )      // [2, 2, 3]
    }
```
하지만 파라미터가 참조(배열 타입)라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다.
따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.


또한 타입 지정을 생략해도 되는 변수와 달리 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서
파라미터 타입을 추론하지 못한다.

그리고 경우에 따라 반환 타입을 생략할 수 있는데, 이런 예외적인 경우는 2가지가 있다. 하나는 유닛(unit) 타입을
반환하는 경우다. 유닛은 자바  void에 해당하는 코틀린 타입으로, 함수가 의미있는 반환값을 돌려주지 않는다는 뜻이다.
```kotlin
    fun prompt(name: String){
222222222222222222    }

    fun prompt(name: String): Unit{
        println("####Hello, $name")
```
***2222

#### 2