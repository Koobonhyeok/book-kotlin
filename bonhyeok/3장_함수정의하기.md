## 함수 
 *  자바 메서드처럼 코틀린 함수도 어떤 입력을 받아서 자신을 호출한 코드 쪽에 출력값을 반환할 수 있는 재사용 가능한 코드 블록이다.

---
#### 코틀린 함수의 구조
자바와 마찬가지로 함수의 결과값을 return 문으로 지정한다. return 문은 함수 실행을 끝내고 호출한 쪽에 제어를
돌려준다. return 문 다음에 위치한 코드는 실질적으로 죽어있는 코드이며, 결코 실행되지 않는다.  

자바처럼 코틀린에도 블록 문이 있다. 블록 문은 기본적으로 {}로 감싼 문의 그룹을 말한다. 
문은 새줄 문자로 분리하거나 세미콜론으로 분리하며, 순서대로 실행된다.

```kotlin
    fun increment(n: Int): Int{
        return n++      // Error : can not change immutable variable
    }
```
자바 메서드 파라미터는 디폴트가 가변이므로 함수 내부에서 변경하지 못하게 하려면 final을 지정해 불변 값으로
바꿔야 하는데, 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하하면 위의 코드 같이 오류가 발생한다.
그리고 파라미터 앞에 **val이나 var**를 표시할 수 없다는 점을 유의하라. 이렇게 강제하는 이유는 
파라미터에 대입하는 중에 실수할 가능성이 높을 뿐 아니라 파라미터를 불변 값으로 강제하는 편이 더 깔끔하고
이해하기 편한 코드를 만들어 내기 때문이다.

```kotlin
    fun increment(a: IntArray): Int{
        return ++a[0]
    }

    fun main(){
        val a = intArrayOf(1, 2, 3)
        println( increment(a) )             // 2
        println( a.contentToString() )      // [2, 2, 3]
    }
```
하지만 파라미터가 참조(배열 타입)라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다.
따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.


또한 타입 지정을 생략해도 되는 변수와 달리 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서
파라미터 타입을 추론하지 못한다.

그리고 경우에 따라 반환 타입을 생략할 수 있는데, 이런 예외적인 경우는 2가지가 있다. 하나는 유닛(unit) 타입을
반환하는 경우다. 유닛은 자바  void에 해당하는 코틀린 타입으로, 함수가 의미있는 반환값을 돌려주지 않는다는 뜻이다.
```kotlin
    fun prompt(name: String){
        println("####Hello, $name")
    }

    fun prompt(name: String): Unit {
        println("####Hello, $name")
    }
```
***

#### vararg 
vararg는 함수 매개변수에 가변 인자를 허용하는 키워드 입니다. 이를 통해 함수에 여러 개의 인자를 전달할 수
있으며, 자바의 가변 인자와 유사한 기능을 제공한다.

```kotlin
    fun printSorted(vararg items: Int){
        items.sort()
        println(items.contentToString())
    }
    
    fun main() {
        printSorted(6, 2, 10, 1)  // 1, 2, 6, 10
    }
```
또한, 스프레드 연산자인 *를 사용하면 배열을 가변 인자 대신 넘길 수 있다.
```kotlin
    val number = intArrayOf(6, 2, 10, 1)
    printSorted(*number)
    printSorted(number)// Error: passing IntArray instead of Int
```
스프레드는 배열을 본사한다는 점에 유의하라. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.
```kotlin
    fun main(){
        val a = intArrayOf(6, 2, 10, 1)
        printSorted(*a)         // [1, 2, 6, 10]
        printSorted(a.contentToString()) // [6, 2, 10 ,1]
    }
```
하지만 이때 얕은 복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 
참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
```kotlin
    fun change(vararg items: IntArray){
        println(items[0].contentToString())
        println(items[1].contentToString())
    
        items[0][0] = 100
    }
    
    fun main() {
        val a = intArrayOf(1, 2, 3)
        val b = intArrayOf(4, 5, 6)
    
        change(a, b)
        println( a.contentToString() )
        println( b.contentToString() )
    
    }
```
```text
kotlin에서 'vararg'는 함수에 가변 인자를 전달 할 수 있도록 해주는 
키워드이며, 가변 인자는 함수에 전달할 인자의 개수가 정해져 있지 않고,
필요에 따라 얼마든지 전달할 수 있는 인자이다.
```
***

#### 함수의 영역과 가시성
코틀린 함수는 정의된 위치에 따라 세 가지로 구분할 수 있다.
1. 파일에 직접 선언된 최상위 함수
2. 어떤 타입 내부에 선언된 멤버 함수
3. 다른 함수 안에 선언된 지역 함수
  
public이라는 변경자도 있다. 하지만 최상위 함수는 디폴트로 공개 가시성을 갖기 때문에 변경자는 불필요한
중복일 뿐이다.  
지역 변수처럼 함수 내부에 지역 함수를 정의할 수 있으며, 이 함수의 영역은 함수를 감싸는 블록으로 한정된다.
```kotlin
    fun main(){
        fun readInt() = 5
        
        println( readInt() + readInt() + 1)
    }
    
    fun readIntPairMain() = intArrayOf( readInt(), readInt()) // error: unresolved reference: readInt
```
지역 함수는 자신을 둘러싼 함수, 블록에 선언된 변수나 함수에 접근할 수 있다. 이런 변수에는 지역 함수를 둘러싸고
있는 함수의 파라미터도 포함된다.
```kotlin
    fun main(){

        fun swap(i: Int, j: Int): String{
             val chars:CharArray = "bonhyeok".toCharArray()
             val tmp = chars[i]
            chars[i] = chars[j]
            chars[j] = tmp
            return chars.concatToString()
        }
        println( swap(0, "bonhyeok".lastIndex) )
    }
```

***

## 3.2 패키지와 임포트

#### 패키지와 디렉터리 구조
코틀린 파일에서도 맨 앞에 패키지 이름을 지정하면 파일에 있는 모든 최상위 선언을 지정한 패키지 내부에 넣을 수 
있다. 패키지를 지정하지 않으면 컴파일러는 파일이 디폴트 최상위 패키지에 속한다고 가정한다. 디폴트 최상위
패키지는 이름이 없다.
  
패키지를 이루는 최상위 선언에는 타입, 함수, 프로퍼티가 있다. 같은 패키지 안에서는 간단한 이름을 사용해 패키지
내에 있는 다른 정의를 참조할 수 있다. 
```kotlin
package foo.bar.kotlinVerse

fun readInt(radix: Int = 10) = readLine()!!.toInt(radix)
```
```kotlin
package foo.bar.kotlinVerse

fun main(){
    println(readInt(8))
}
```
***
#### 임포트 디렉티브 사용하기
이번 절에서는 코틀린이 제공하는 여러 가지 임포드 디렉티브를 소개하고 각각 자바의 비슷한 기능과 어떻게 다른지 살펴본다.  
지금까지 예제에서 봤던 가장 단순한 임포트 형태는 전체 이름을 지정해 어떤 선언을 임포트 하는 것이다.
```kotlin
import java.lang.Math       // JDk 클래스
import foo.bar.util.readInt // 최상위 함수
```
임포트 디렉티브가 클래스나 함수 등의 최상위 선언만 임포트할 수 있는 것은 아니다. 클래스 안에 내포된 클래스나
다음 예제처럼 이넘 상수등도 임포트할 수 있다.
```kotlin
import kotlin.Int.Companion.MIN_VALUE
fun fromMin(steps: Int) = MIN_VALUE + n // MIN_VALUE를 간단한 이름으로 가리킴
```
* 자바와 달리 코틀린의 타입 멤버를 임포트하는 별도의 import static 디렉티브가 없다. 코틀린의 모든 선언은 
일반적인 임포트 디렉티브 구문을 사용해 임포트할 수 있다.

서로 다른 패키지에 있는 일부 선언의 이름은 똑같을 수도 있다. 이런 이름들을 한 파일에서 쓰려면 아래의 코드처럼
작성하여 사용을 할 수 있다.
```kotlin
import app.util.foo.readInt
import app.util.bar.readInt

fun main(){
    val n = readInt() // 오류: 두 가지 readInt() 중 하나만 선택할 수 없음
}
```
이 둘을 구분하려면 항상 전체 이름을 사용해야 한다. 하지만 코틀린은 임포트 별명(alias)이라는 더 나은 해법을 제공한다.
```kotlin
import app.util.foo.readInt     as fooReadInt
import app.util.bar.readInt     as barReadInt

fun main(){
    val n = fooReadInt()
    val m = barReadInt()
}
```
그리고 또 다른 형태인 임포트로 어떤 영역에 속한 모든 선언을 한꺼번에 임포트할 수 있다.
```kotlin
import kotlin.math.*
```
****

## 3.3 조건문